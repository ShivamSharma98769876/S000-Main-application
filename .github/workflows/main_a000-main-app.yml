# Docs for the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
# More GitHub Actions for Azure: https://github.com/Azure/actions
# More info on Node.js, GitHub Actions, and Azure App Service: https://aka.ms/nodejs-webapps-actions

name: Build and deploy Node.js app to Azure Web App - A000-Main-App

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read #This is required for actions/checkout

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js version
        uses: actions/setup-node@v4
        with:
          node-version: '18.x'

      # ðŸ› ï¸ Local Build Section (Optional)
      # The following section in your workflow is designed to catch build issues early on the client side, before deployment. This can be helpful for debugging and validation. However, if this step significantly increases deployment time and early detection is not critical for your workflow, you may remove this section to streamline the deployment process.
      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: backend/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('backend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        working-directory: ./backend
        run: |
          npm ci
                
      # By default, when you enable GitHub CI/CD integration through the Azure portal, the platform automatically sets the SCM_DO_BUILD_DURING_DEPLOYMENT application setting to true. This triggers the use of Oryx, a build engine that handles application compilation and dependency installation (e.g., npm install) directly on the platform during deployment. Hence, we exclude the node_modules directory from the deployment artifact to reduce the payload size. 
      - name: Prepare deployment package
        working-directory: ./backend
        run: |
          # Ensure package.json and package-lock.json exist
          if [ ! -f package.json ]; then
            echo "ERROR: package.json not found in backend directory!"
            exit 1
          fi
          echo "âœ“ package.json verified"
          ls -la package.json package-lock.json 2>/dev/null || echo "Note: package-lock.json may not exist"
      
      - name: Prepare deployment artifact
        run: |
          # Create a temporary directory with backend contents at root
          # This ensures Azure gets package.json at the root level
          # Exclude database files and data directory from deployment
          mkdir -p deploy-package
          
          # First, explicitly remove any database files from backend directory (in case they exist)
          echo "Cleaning up any database files from backend directory..."
          find backend -type f \( -name "*.db" -o -name "*.db-shm" -o -name "*.db-wal" -o -name "*.sqlite" -o -name "*.sqlite3" \) -delete 2>/dev/null || true
          find backend -type d -name "data" -exec rm -rf {} + 2>/dev/null || true
          
          # Copy all files from backend, excluding database files and data directories
          cd backend
          find . -type f ! -path "*/node_modules/*" ! -path "*/.git/*" \
                ! -name "*.db" ! -name "*.db-shm" ! -name "*.db-wal" \
                ! -name "*.sqlite" ! -name "*.sqlite3" \
                ! -path "*/data/*" ! -path "./data/*" \
                ! -path "*/logs/*" ! -name "*.log" \
                -exec sh -c 'mkdir -p "../deploy-package/$(dirname "$1")" && cp "$1" "../deploy-package/$1"' _ {} \;
          
          # Copy hidden files (but exclude .git, .env, database files, etc.)
          find . -maxdepth 1 -name ".*" ! -name ".git" ! -name ".env*" ! -name ".DS_Store" \
                ! -name "*.db" ! -name "*.db-shm" ! -name "*.db-wal" \
                -exec sh -c 'cp -r "$1" "../deploy-package/"' _ {} \; 2>/dev/null || true
          cd ..
          
          # Copy public directory (frontend static files) to deploy-package
          echo "Copying public directory..."
          if [ -d "public" ]; then
            cp -r public deploy-package/public
            echo "âœ“ Public directory copied"
          else
            echo "WARNING: public directory not found!"
          fi
          
          # Explicitly remove any database files that might have been copied
          echo "Removing any database files from deployment package..."
          find deploy-package -type f \( -name "*.db" -o -name "*.db-shm" -o -name "*.db-wal" -o -name "*.sqlite" -o -name "*.sqlite3" \) -delete 2>/dev/null || true
          find deploy-package -type d -name "data" -exec rm -rf {} + 2>/dev/null || true
          
          # Verify package.json is at root
          if [ ! -f "deploy-package/package.json" ]; then
            echo "ERROR: Failed to copy package.json to deploy-package/"
            exit 1
          fi
          
          echo "âœ“ Deployment package prepared (database files excluded)"
          echo "Files in deployment package:"
          ls -la deploy-package/ | head -15
          
          # Verify database files are excluded
          if find deploy-package -name "*.db" -o -name "*.sqlite*" 2>/dev/null | grep -q .; then
            echo "ERROR: Database files found in deployment package! Removing..."
            find deploy-package -name "*.db" -o -name "*.sqlite*" 2>/dev/null
            find deploy-package -type f \( -name "*.db" -o -name "*.db-shm" -o -name "*.db-wal" -o -name "*.sqlite" -o -name "*.sqlite3" \) -delete
            echo "Database files removed"
          else
            echo "âœ“ Verified: No database files in deployment package"
          fi
          
          # Verify no data directory
          if [ -d "deploy-package/data" ]; then
            echo "WARNING: data directory found in deployment package! Removing..."
            rm -rf deploy-package/data
            echo "data directory removed"
          fi
      
      - name: Upload artifact for deployment jobs
        uses: actions/upload-artifact@v4
        with:
          name: node-app
          path: deploy-package/
          retention-days: 1

      # ðŸš« Opting Out of Oryx Build
      # If you prefer to disable the Oryx build process during deployment, follow these steps:
      # 1. Remove the SCM_DO_BUILD_DURING_DEPLOYMENT app setting from your Azure App Service Environment variables.
      # 2. Refer to sample workflows for alternative deployment strategies: https://github.com/Azure/actions-workflow-samples/tree/master/AppService
      

  deploy:
    runs-on: ubuntu-latest
    needs: build
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: node-app
          path: .
      
      - name: Clean up database files from deployment package
        run: |
          echo "Cleaning up any database files from deployment package..."
          # Remove any database files that might have been included
          find . -type f \( -name "*.db" -o -name "*.db-shm" -o -name "*.db-wal" -o -name "*.sqlite" -o -name "*.sqlite3" \) -delete 2>/dev/null || true
          # Remove data directories
          find . -type d -name "data" -exec rm -rf {} + 2>/dev/null || true
          # Verify cleanup
          if find . -name "*.db" -o -name "*.sqlite*" 2>/dev/null | grep -q .; then
            echo "WARNING: Some database files still exist after cleanup"
            find . -name "*.db" -o -name "*.sqlite*" 2>/dev/null
          else
            echo "âœ“ Verified: No database files in deployment package"
          fi
      
      - name: Verify deployment package
        run: |
          # Check current directory structure after artifact download
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          echo ""
          
          # The artifact should have package.json at root (from deploy-package/)
          if [ -f "package.json" ]; then
            echo "âœ“ Found package.json at root (expected)"
            echo "Package.json contents (name field):"
            cat package.json | grep -A 2 '"name"'
          else
            echo "ERROR: package.json not found at root!"
            echo "Searching for package.json:"
            find . -name "package.json" -type f 2>/dev/null
            exit 1
          fi
          
          # Verify other key files
          echo ""
          echo "Key files verification:"
          [ -f "server.js" ] && echo "âœ“ server.js" || echo "âœ— server.js missing"
          [ -f ".oryx" ] && echo "âœ“ .oryx" || echo "âœ— .oryx missing"
          [ -d "routes" ] && echo "âœ“ routes/" || echo "âœ— routes/ missing"
          [ -d "config" ] && echo "âœ“ config/" || echo "âœ— config/ missing"
      
      - name: Create Oryx configuration for Node.js
        run: |
          # Create .oryx file to explicitly specify Node.js (prevents Python detection)
          echo "PLATFORM_NAME=nodejs" > .oryx
          echo "PLATFORM_VERSION=18" >> .oryx
          echo "âœ“ Created .oryx configuration file"
          cat .oryx
          
          # Also create oryx-manifest.toml
          cat > oryx-manifest.toml << EOF
          # Oryx build manifest - explicitly specify Node.js
          [build]
          platform = "nodejs"
          platform_version = "18"
          EOF
          echo "âœ“ Created oryx-manifest.toml"
          
          # Verify package.json is present and valid
          echo "Verifying package.json:"
          cat package.json | head -10
          
          # Remove any Python-related files that might confuse Oryx
          echo "Checking for Python files that might confuse Oryx:"
          find . -name "requirements.txt" -o -name "*.py" 2>/dev/null | head -5 || echo "No Python files found (good!)"
      
      - name: Create .deploymentignore in package
        run: |
          # Create .deploymentignore file to tell Azure to exclude database files
          cat > .deploymentignore << 'EOF'
          # Exclude database files from Azure deployment
          *.db
          *.db-shm
          *.db-wal
          *.sqlite
          *.sqlite3
          data/
          **/data/
          logs/
          *.log
          .env*
          node_modules/
          EOF
          echo "âœ“ Created .deploymentignore file"
          cat .deploymentignore
      
      - name: 'Deploy to Azure Web App'
        uses: azure/webapps-deploy@v3
        id: deploy-to-webapp
        with:
          app-name: 'A000-Main-App'
          slot-name: 'Production'
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_BCCDD66C2B2240B2B334EBFDA892DF8F }}
          package: '.'
